#!/usr/bin/env python
#
# Copyright (c) 2013 Rafael Martinez Guerrero (PostgreSQL-es)
# rafael@postgresql.org.es / http://www.postgresql.org.es/
#
# This file is part of PgBck
# https://github.com/rafaelma/pgbck
#
# PgBck is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# PgBck is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PgBck.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import sys
import os
import time
import signal
import argparse

sys.path.append('/home/rafael/Devel/GIT/pgbackman')

from pgbackman.logs import *
from pgbackman.database import * 
from pgbackman.config import *



# ############################################
# Function 
# ############################################
    
def pg_dump(backup_server_pgsql_bin_dir,filename_id):
    '''pg_dump function'''

    if backup_code == 'FULL':

        print backup_server_pgsql_bin_dir + '/pg_dump' + \
            ' -h ' + pgsql_node + \
            ' -p ' + pgsql_node_port + \
            ' -U ' + pgsql_node_admin_user + \
            ' --file=' + filename_id + '.sql' + \
            ' --format=c' + \
            ' --blobs' + \
            ' ' + extra_parameters + \
            ' ' + dbname + \
            ' > ' +  filename_id + '.log 2>&1' 
        
    elif backup_code == 'SCHEMA':
        
        print backup_server_pgsql_bin_dir + '/pg_dump' + \
            ' -h ' + pgsql_node + \
            ' -p ' + pgsql_node_port + \
            ' -U ' + pgsql_node_admin_user + \
            ' --file=' + filename_id + '.sql' + \
            ' --format=c' + \
            ' --schema-only' + \
            ' ' + extra_parameters + \
            ' ' + dbname + \
            ' > ' +  filename_id + '.log 2>&1' 
        
    elif backup_code == 'DATA':
        
        print backup_server_pgsql_bin_dir + '/pg_dump' + \
            ' -h ' + pgsql_node + \
            ' -p ' + pgsql_node_port + \
            ' -U ' + pgsql_node_admin_user + \
            ' --file=' + filename_id + '.sql' + \
            ' --format=c' + \
            ' --data-only' + \
            ' ' + extra_parameters + \
            ' ' + dbname + \
            ' > ' +  filename_id + '.log 2>&1' 
        
        
    




# ############################################
# Function 
# ############################################
    
def pg_dump_users():
    '''pg_dump_users function'''


# ############################################
# Function 
# ############################################
    
def pg_dump_database_config():
    '''pg_dump_database_config function'''



# ############################################
# Function handler
# ############################################
    
def get_pgsql_node_dsn(db):
    '''Get the DSN values for a pgsql_node'''

    pgsql_node_id = db.get_pgsql_node_id(pgsql_node)
    dsn_value = db.get_pgsql_node_dsn(pgsql_node_id)

    if dsn_value != None:
        logs.logger.debug('DSN value for PgSQL node %s is %s',pgsql_node,dsn_value)
        return dsn_value
    else:
        logs.logger.critical('PgSQL node: %s is not registered in PgBackMan',pgsql_node)
        sys.exit(1)


# ############################################
# Function handler
# ############################################
    
def get_pgsql_node_release(db):
    '''Get the release pgsql_node is running'''

    pgsql_node_version = str(db.get_server_version())[0:4]
        
    if pgsql_node_version == '9030':
        pgsql_node_release = '9.3'
    elif pgsql_node_version == '9020':
        pgsql_node_release = '9.2'
    elif pgsql_node_version == '9010':
        pgsql_node_release = '9.1'
    elif pgsql_node_version == '9000':
        pgsql_node_release = '9.0'
    elif pgsql_node_version == '8040':
        pgsql_node_release = '8.4'
    else:
        pgsql_node_release = None

    if  pgsql_node_release != None:
        logs.logger.debug('PgSQL node %s is running postgreSQL %s',pgsql_node,pgsql_node_release)
        return pgsql_node_release
    else:
        logs.logger.critical('Could not get the postgreSQL release for this PgSQL node: %s',pgsql_node)
        sys.exit(1)
    
    
# ############################################
# Function handler
# ############################################
    
def get_backup_server_pgsql_bin_dir(db,backup_server_id,pgsql_node_release):
    '''Get the directory with postgreSQL binaries to use'''

    pgsql_bin_dir = db.get_backup_server_parameter(backup_server_id,'pgsql_bin_' + pgsql_node_release)

    if pgsql_bin_dir != None:
        logs.logger.debug('pgsql bin directory to use: %s',pgsql_bin_dir)
        return pgsql_bin_dir
    else:
        logs.logger.critical('Could not get the pgsql bin directory for this PgSQL node: %s',pgsql_node)
        sys.exit(1)


# ############################################
# Function handler
# ############################################
    
def get_filename_id(pgsql_node_release):
    '''Generate the filename used for the backup and log file of a backup job'''
    
    timestamp = datetime.datetime.now().strftime('%Y%m%dT%H%M%S')
    filename_id = dbname + '-' + pgsql_node + '-v' + pgsql_node_release + '-j' + backup_job_id + '-c' + backup_code + '-fCUSTOM-' + timestamp 

    return filename_id


# ############################################
# Function handler
# ############################################
    
def check_pgsql_node_backup_directories(db):
    '''
    Check if the directories needed by pgbackman for a PgSQL node are in place
    If they do not exist, we try to create them.
    '''

    pgsql_node_id = db.get_pgsql_node_id(pgsql_node)
    pgsql_node_backup_dir = db.get_pgsql_node_parameter(pgsql_node_id,'pgnode_backup_partition')

    if  pgsql_node_backup_dir != None:
        logs.logger.debug('PgSQL node backup partition to use: %s',pgsql_node_backup_dir)
        
        if os.path.exists(pgsql_node_backup_dir + '/dump'):
            logs.logger.debug('Dump directory %s exists',pgsql_node_backup_dir + '/dump')
        else:
            logs.logger.error('Dump directory %s does not exist',pgsql_node_backup_dir + '/dump')
            
            try:
                os.makedirs(pgsql_node_backup_dir + '/dump',0700)
                logs.logger.info('Dump directory %s created',pgsql_node_backup_dir + '/dump')
            except OSError as e:
                logs.logger.critical('OS error when creating the dump directory: %s',e)
                sys.exit(1)
                
        if os.path.exists(pgsql_node_backup_dir + '/log'):
            logs.logger.debug('Log directory %s exists',pgsql_node_backup_dir + '/log')
        else:
            logs.logger.error('Log directory %s does not exist',pgsql_node_backup_dir + '/log')
            
            try:
                os.makedirs(pgsql_node_backup_dir + '/log',0700)
                logs.logger.info('Log directory %s created',pgsql_node_backup_dir + '/log')
            except OSError as e:
                logs.logger.critical('OS error when creating the log directory: %s',e)
                sys.exit(1)       

    else:
        logs.logger.critical('Could not get the PgSQL node backup partition for: %s',pgsql_node)
        sys.exit(1)


# ############################################
# Function handler
# ############################################
    
def signal_handler(signum, frame):
    logs.logger.info('**** pgbackman_dump stopped. ****')
    sys.exit(0)


# ############################################
# Function 
# ############################################
    
def main():
    '''Main function'''
    
    conf = configuration()
    pgbackman_dsn = conf.dsn
    
    db = pgbackman_db(pgbackman_dsn,logs,'pgbackman_dump')

    pgsql_node_dsn = get_pgsql_node_dsn(db)
    db_pgnode = pgbackman_db(pgsql_node_dsn,logs,'pgbackman_dump')

    # 
    # The backup server FQDN to be used can be defined in the pgbackman configuration file.
    # If the configuration parameter 'backup_server' is not defined, the return value of  
    # socket.getfqdn() will be used.
    #
    # The FQDN of the backup server will be used to find out the internal pgbackman ID of the backup 
    # server
    #

    if conf.backup_server != '':
        backup_server_id = db.get_backup_server_id(conf.backup_server)
        
        if backup_server_id == False:
            logs.logger.critical('Backup server %s does not exist in pgbackman. Stopping pgbackman2cron.',conf.backup_server)
            logs.logger.info('**** pgbackman_dump stopped. ****')
            sys.exit()     
        else:
            logs.logger.debug('Backup server: %s up and running',conf.backup_server)
    else:
        backup_server_id = db.get_backup_server_id(socket.getfqdn())

        if backup_server_id == False:
            logs.logger.critical('Backup server %s does not exist in pgbackman. Stopping pgbackman2cron.',socket.getfqdn())
            logs.logger.info('**** pgbackman_dump stopped. ****')
            sys.exit()     
        else:
            logs.logger.debug('Backup server: %s up and running',socket.getfqdn())

    print backup_server_id
    
    pgsql_node_release = get_pgsql_node_release(db_pgnode)
    print pgsql_node_release

    backup_server_pgsql_bin_dir = get_backup_server_pgsql_bin_dir(db,backup_server_id,pgsql_node_release)
    print backup_server_pgsql_bin_dir

    check_pgsql_node_backup_directories(db)

    filename_id = get_filename_id(pgsql_node_release)
    pg_dump(backup_server_pgsql_bin_dir,filename_id)

# ############################################
# 
# ############################################

if __name__ == '__main__':

    logs = logs("pgbackman_dump")

    signal.signal(signal.SIGINT,signal_handler)
    signal.signal(signal.SIGTERM,signal_handler)

    parser = argparse.ArgumentParser(prog=sys.argv[0])
    parser.add_argument('-H', metavar='PGSQL-NODE', required=True, help='PgSQL node FQDN', dest='pgsql_node')
    parser.add_argument('-p', metavar='PGSQL-NODE-PORT', required=True, help='PgSQL node port', dest='pgsql_node_port')
    parser.add_argument('-U', metavar='PGSQL-NODE_ADMIN-USER', required=True, help='PgSQL node admin user', dest='pgsql_node_admin_user')
    parser.add_argument('-j', metavar='JOBID', required=True, help='Backup job ID', dest='backup_job_id')
    parser.add_argument('-d', metavar='DBNAME', required=True, help='Database name', dest='dbname')
    parser.add_argument('-c', metavar='[FULL|SCHEMA|DATA]', choices=['FULL', 'SCHEMA', 'DATA'], required=True, help='Backup code', dest='backup_code')
    parser.add_argument('-e', metavar='[FALSE|TRUE]', default=False, required=True, help='Activate encryption', dest='encryption')
    parser.add_argument('-P', metavar='EXTRA-PARAMETERS', required=False, help='extra pg_dump parameters', dest='extra_parameters')

    args = parser.parse_args()    
    print args

    logs.logger.info('**** pgbackman_dump started. ****')
    
    if args.pgsql_node:
        pgsql_node = args.pgsql_node
    else:
        logs.logger.error('PgSQL node parameter not defined')
        sys.exit(1)

    if args.pgsql_node_port:
        pgsql_node_port = args.pgsql_node_port
    else:
        logs.logger.error('PgSQL node port parameter not defined')
        sys.exit(1)
    
    if args.pgsql_node_admin_user:
        pgsql_node_admin_user = args.pgsql_node_admin_user
    else:
        logs.logger.error('PgSQL node admin user parameter not defined')
        sys.exit(1)
    
    if args.backup_job_id:
        backup_job_id = args.backup_job_id
    else:
        logs.logger.error('Backup jobID parameter not defined')
        sys.exit(1)

    if args.dbname:
        dbname = args.dbname
    else:
        logs.logger.error('DBname parameter not defined')
        sys.exit(1)

    if args.encryption:
        encryption = args.encryption
    else:
        logs.logger.error('Encryption parameter not defined')
        sys.exit(1)
        
    if args.backup_code:
        backup_code = args.backup_code
    else:
        logs.logger.error('Backup code parameter not defined')
        sys.exit(1)

    if args.extra_parameters:
        extra_parameteres = args.extra_parameteres
    else:
        extra_parameters = ''

    main()
